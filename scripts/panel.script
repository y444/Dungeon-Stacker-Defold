go.property("row", 0)
go.property("length", 0)
go.property("speed", 0)
go.property("is_moving", false)
go.property("stop_pos", 0)

local function setup_position(self)
	self.left = vmath.vector3(24, 24 + self.row * 16, -4)
	self.right = vmath.vector3(136 - self.length * 16, 24 + self.row * 16, -4)
	local start_options = {self.left, self.right}
	local start = start_options[math.random(#start_options)]
	if start == self.right then self.direction = -1 else self.direction = 1 end
	go.set_position(start,".")
end

local function spawn_blocks(self)
	self.blocks = {}
	local random_block_number = math.random(self.length)
	for i = 1, self.length do
		local selected_reward = 0
		if i == random_block_number then
			selected_reward = 1
			if self.row == 11 then selected_reward = 2 end
		end
		local block_id = factory.create("#block_factory", vmath.vector3((i - 1) * 16, 0, 0), nil, {reward = selected_reward})
		local block_url = msg.url(block_id)
		block_url.fragment = "block"
		table.insert(self.blocks, block_url)
		go.set_parent(block_id, msg.url())
	end
end

local function make_borders(self)
	for i = 1, #self.blocks do
		if i == 1 then
			local border_pos = vmath.vector3(-16, 0, -1) 
			local border_id = factory.create("#border_factory", border_pos, nil, {side = 0})
			go.set_parent(border_id, self.blocks[i])
		end
		if i == #self.blocks then
			local border_pos = vmath.vector3(16, 0, -1) 
			local border_id = factory.create("#border_factory", border_pos, nil, {side = 1})
			go.set_parent(border_id, self.blocks[i])
		end
		local top_border_url = self.blocks[i]
		top_border_url.fragment = "border_sprite"
		msg.post(top_border_url, "enable")
	end
end

function init(self)
	self.timer = self.speed
	self.is_moving = true
	setup_position(self)
	spawn_blocks(self)
end

function update(self, dt)
	if self.is_moving then
		local position = go.get_position()
		if self.timer <= 0 then
			self.timer = self.speed
			if position == self.left or position == self.right then self.direction = -self.direction end
			go.set_position(vmath.vector3(position.x - self.direction * 16, position.y, position.z))
		end
		self.timer = self.timer - dt
	end
end

local function is_right_alive(self, dead)
	for i = 1, #dead do
		if dead[i] == #self.blocks then return false end
	end
	return true
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trim") then
		local trim_left = 0
		for i = 1, #message.dead do
			if (is_right_alive(self, message.dead)) then
				local pos = go.get_position()
				local new_pos = pos + vmath.vector3(16, 0, 0)
				go.set_position(new_pos)
				trim_left = trim_left + 1
			end
		end
		for i = #message.dead, 1, -1 do
			go.delete(self.blocks[message.dead[i]], true)
			table.remove(self.blocks,message.dead[i])
		end
		self.length = self.length - #message.dead
		for i = 1, #self.blocks do
			local block_pos = go.get_position(self.blocks[i])
			local new_block_pos = block_pos - vmath.vector3(16 * trim_left, 0, 0)
			go.set_position(new_block_pos, self.blocks[i])
		end
		if self.length < 0 then self.length = 0 end
		if self.length > 0 then make_borders(self) end
	end
end