go.property("row", 0)
go.property("length", 0)
go.property("speed", 0)
go.property("is_moving", false)
go.property("stop_pos", 0)

local function setup_position(self)
	self.left = vmath.vector3(24, 24 + self.row * 16, -4)
	self.right = vmath.vector3(136 - self.length * 16, 24 + self.row * 16, -4)
	local start_options = {self.left, self.right}
	local start = start_options[math.random(#start_options)]
	if start == self.right then self.direction = -1 else self.direction = 1 end
	go.set_position(start,".")
end

local function spawn_blocks(self)
	self.blocks = {}
	local random_block_number = math.random(self.length)
	for i = 1, self.length do
		local selected_reward = 0
		if i == random_block_number then
			selected_reward = 1
			if self.row == 11 then selected_reward = 2 end
		end
		local block_id = factory.create("#block_factory", vmath.vector3((i - 1) * 16, 0, 0), nil, {reward = selected_reward})
		local block_url = msg.url(block_id)
		block_url.fragment = "block"
		table.insert(self.blocks, block_url)
		go.set_parent(block_id, msg.url())
	end
end

local function make_borders(self)
	--TODO
end

function init(self)
	self.timer = self.speed
	self.is_moving = true
	setup_position(self)
	spawn_blocks(self)
end

function update(self, dt)
	if self.is_moving then
		local position = go.get_position()
		if self.timer <= 0 then
			self.timer = self.speed
			if position == self.left or position == self.right then self.direction = -self.direction end
			go.set_position(vmath.vector3(position.x - self.direction * 16, position.y, position.z))
		end
		self.timer = self.timer - dt
	end
end

function on_message(self, message_id, message, sender)
	if message_id == hash("trim") then
		for i = #message.dead, 1, -1 do
			go.delete(self.blocks[message.dead[i]], true)
			table.remove(self.blocks,message.dead[i])
		end
		self.length = self.length - #message.dead
		if self.length < 0 then self.length = 0 end
		if self.length > 0 then make_borders(self) end
	end
end